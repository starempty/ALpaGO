## 1. 선택 정렬(Selection Sort)

선택 정렬은 현재 위치에 들어갈 값을 찾아 정렬하는 배열이다. 현재 위치에 저장될 값의 크기가 작냐, 크냐에 따라 최소 선택 정렬(Min-Selection Sort)와 최대 선택 정렬(Max-Selection Sort)로 구분할 수 있다. 최소 선택 정렬은 오름차순으로 정렬되고, 최대 선택 정렬은 내림차순으로 정렬된다.

1. 정렬되지 않은 인덱스의 맨 앞부터, 이를 포함한 그 이후의 배열 값 중 가장 작은 값을 찾아간다.
2. 가장 작은 값을 찾으면, 그 값을 현재 인덱스 값과 바꿔준다.
3. 다음 인덱스에서 위의 과정을 반복한다.

→ n-1개, n-2개, ... 1개씩 비교를 반복한다.

- **_시간복잡도_**
  - O(n^2)
- **_공간복잡도_**
  - O(n)
- **in-place 하다**
- **unstable 하다**

## 2. 삽입 정렬(Insertion Sort)

삽입 정렬은 현재 위치에서, 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아, 그 위치에 삽입하는 배열 알고리즘이다.

1. 삽입 정렬은 두번째 인덱스부터 시작한다. 현재 인덱스는 별도의 변수에 저장하고, 비교 인덱스를 (현재 인덱스 - 1)로 잡는다.
2. 별도로 저장해 둔 삽입을 위한 변수와, 비교 인덱스의 배열 값을 비교한다.
3. 삽입 변수의 값이 더 작으면 현재 인덱스로 비교 인덱스의 값을 저장해주고, 비교 인덱스 - 1 하여 비교를 반복한다.
4. 만약, 삽입 변수가 더 크면 비교 인덱스 + 1에 삽입 변수를 저장한다.

- **_시간복잡도_**

  - 최악의 경우(역으로 정렬되어있는 경우)에는 n-1, n-2, ..., 1개씩 비교를 반복하여 시간복잡도가 O(n^2)
  - 이미 정렬되어 있는 경우에는 한번씩만 비교하므로 시간복잡도는 O(n)
  - 하지만, Big-O notation은 상한을 기준으로 하므로 시간복잡도는 결과적으로 O(n^2)이다.

- **_공간복잡도_**
  - 하나의 배열에서만 진행하므로 O(n)
- **in-place 하다**
- **stable 하다**

## 3. 퀵 정렬(Quick Sort)

퀵 정렬 또한 분할정복(Divide and conquer)을 이용하여 정렬을 수행하는 알고리즘이다.

pivot point라고 기준이 되는 값을 하나 설정하는데, 이 값을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 옮기는 방식으로 정렬을 진행한다.

이를 반복하여 분할된 배열의 크기가 1이되면, 배열이 모두 정렬된 것이다.

1. pivot point로 잡을 배열의 값 하나를 정한다. 보통 맨 앞이나 맨 뒤, 혹은 전체 배열 값 중 중간값이나 랜덤 값으로 정한다.
2. 분할을 진행하기에 앞서, 비교를 진행하기 위해 가장 왼쪽 배열의 인덱스를 저장하는 left 변수, 가장 오른쪽 배열의 인덱스를 저장하는 right 변수를 생성한다.
3. right부터 비교를 진행한다. 비교는 right가 left보다 클 때만 반복하며, 비교한 배열값이 pivot point보다 크면 right를 하나 감소시키고 비교를 반복한다.

   pivot point보다 작은 배열 값을 찾으면 반복을 중지한다.

4. 그 다음 left부터 비교를 진행한다. 비교는 right가 left보다 클 때만 반복하며, 비교한 배열값이 pivot point보다 작으면 left를 하나 증가시키고 비교를 반복한다.

   pivot point보다 큰 배열 값을 찾으면 반복을 중지한다.

5. left 인덱스 값과 right 인덱스 값을 바꿔준다.
6. 3,4,5번 과정을 left<right가 만족할 때까지 반복한다.
7. 위 과정이 끝나면 left의 값과 pivot point를 바꿔준다.
8. 맨 왼쪽부터 left-1까지, left+1부터 맨 오른쪽까지 나눠서 퀵 정렬을 반복한다.

- 시간복잡도
  - 퀵 정렬은 분할과 동시에 정렬을 진행하는 알고리즘이다.
  - 각 정렬은 배열의 크기 N만큼 비교하며, 이를 총 분할 깊이인 logN만큼 진행하므로 총 비교횟수는 NlogN 이다. → O(NlogN)
  - 다만, 퀵정렬에서 최악의 경우는 이미 배열이 정렬되어있는 경우이다. 이 경우 분할이 N만큼 일어나므로 시간복잡도는 O(N^2)이다.
  - 최악의 경우 때문에 합병정렬보다 느린 알고리즘이라고 생각하기 쉽지만, 발생할 가능성이 잘 없고 일반적으로 퀵정렬이 합병정렬보다 20%이상 빠르다.
- 공간복잡도
  - 단 하나의 배열만을 사용하므로 O(N)
- **in-place 하다**
- **unstable 하다**
